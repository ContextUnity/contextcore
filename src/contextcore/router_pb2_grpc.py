# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from . import context_unit_pb2 as context__unit__pb2

GRPC_GENERATED_VERSION = '1.78.0'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + ' but the generated code in router_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class RouterServiceStub(object):
    """=====================================================
    Router Service - AI Agent Orchestration
    =====================================================
    All methods use ContextUnit as input/output.
    Agent identification and input is passed via payload.
    =====================================================

    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.ExecuteAgent = channel.unary_unary(
                '/contextrouter.RouterService/ExecuteAgent',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)
        self.StreamAgent = channel.unary_stream(
                '/contextrouter.RouterService/StreamAgent',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)
        self.ExecuteDispatcher = channel.unary_unary(
                '/contextrouter.RouterService/ExecuteDispatcher',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)
        self.StreamDispatcher = channel.unary_stream(
                '/contextrouter.RouterService/StreamDispatcher',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)
        self.RegisterTools = channel.unary_unary(
                '/contextrouter.RouterService/RegisterTools',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)
        self.DeregisterTools = channel.unary_unary(
                '/contextrouter.RouterService/DeregisterTools',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)
        self.ToolExecutorStream = channel.stream_stream(
                '/contextrouter.RouterService/ToolExecutorStream',
                request_serializer=context__unit__pb2.ContextUnit.SerializeToString,
                response_deserializer=context__unit__pb2.ContextUnit.FromString,
                _registered_method=True)


class RouterServiceServicer(object):
    """=====================================================
    Router Service - AI Agent Orchestration
    =====================================================
    All methods use ContextUnit as input/output.
    Agent identification and input is passed via payload.
    =====================================================

    """

    def ExecuteAgent(self, request, context):
        """Execute a single turn of an agent
        Request payload: {tenant_id, agent_id, input_text, context?: {...}}
        Response payload: {output_text, tool_calls?: {...}, metadata?: {...}}
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamAgent(self, request, context):
        """Stream agent execution (for UI with real-time output)
        Request payload: {tenant_id, agent_id, input_text, context?: {...}}
        Response payload: {output_text, tool_calls?: {...}, metadata?: {...}}
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ExecuteDispatcher(self, request, context):
        """=========================================
        Dispatcher Agent - Always-Active Agent
        =========================================

        Execute dispatcher agent (always-active agent with all tools)
        Request payload: {tenant_id, messages: [{role, content}], session_id?, platform?, max_iterations?}
        Response payload: {messages: [...], session_id, metadata: {...}}
        Security: Uses SecurityScopes from ContextUnit for access control
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def StreamDispatcher(self, request, context):
        """Stream dispatcher agent execution
        Request payload: {tenant_id, messages: [{role, content}], session_id?, platform?, max_iterations?}
        Response payload: {event_type, data: {...}} (streaming events)
        Security: Uses SecurityScopes from ContextUnit for access control
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def RegisterTools(self, request, context):
        """=========================================
        Project Tool & Graph Registration
        =========================================

        Register project tools and graph in Router.
        SQL tools use ToolExecutorStream for remote execution —
        DB credentials never leave the project's process.

        Security: Requires "tools:register" write scope in ContextUnit.

        Request payload: {
        project_id: "contextmed",
        tools: [{
        name: "execute_medical_sql",
        type: "sql",
        description: "...",
        config: {
        project_id: "contextmed",              # for stream routing
        schema_description: "...",              # DB schema for LLM
        read_only: true,                       # constraint: SELECT only
        max_rows: 500,
        statement_timeout_ms: 5000,
        schema_description: "..."
        }
        }],

        # Graph — choose one:

        # Option A: Use Router's built-in graph template with project config
        graph: {
        name: "contextmed",
        template: "sql_analytics",            # built-in template
        config: {
        planner_prompt: "Ти — медичний аналітик...",
        verifier_prompt: "Перевір SQL...",
        visualizer_prompt: "Сформуй UI...",
        tool_bindings: ["execute_medical_sql"],
        max_retries: 2
        }
        }

        # Option B: Declarative custom graph
        graph: {
        name: "my_custom_graph",
        nodes: [
        {name: "step1", type: "llm", prompt: "..."},
        {name: "step2", type: "tool", tool: "my_tool"},
        ...
        ],
        edges: [
        {from: "START", to: "step1"},
        {from: "step1", to: "step2", condition: "..."},
        ...
        ]
        }
        }

        Response payload: {registered_tools: [...], graph: "contextmed", status: "ok"}
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def DeregisterTools(self, request, context):
        """Deregister project tools and graph (on shutdown).
        Request payload: {project_id: "contextmed"}
        Response payload: {deregistered: [...], status: "ok"}
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ToolExecutorStream(self, request_iterator, context):
        """=========================================
        Tool Executor Stream (Bidi Callback)
        =========================================

        Bidirectional stream for project-side tool execution.
        Project connects once and acts as remote executor for its tools.
        Uses existing gRPC connection — no new ports needed.

        Flow:
        1. Project → Router: {"action": "ready", "project_id": "nszu",
        "tools": ["execute_medical_sql"]}
        2. Router → Project: {"action": "execute", "tool": "execute_medical_sql",
        "request_id": "abc", "args": {"sql": "SELECT ..."}}
        3. Project → Router: {"action": "result", "request_id": "abc",
        "columns": [...], "rows": [...], "row_count": N}
        4. On error:
        Project → Router: {"action": "error", "request_id": "abc",
        "error": "timeout"}

        Security: Requires ContextToken with "tools:execute" permission.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_RouterServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'ExecuteAgent': grpc.unary_unary_rpc_method_handler(
                    servicer.ExecuteAgent,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
            'StreamAgent': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamAgent,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
            'ExecuteDispatcher': grpc.unary_unary_rpc_method_handler(
                    servicer.ExecuteDispatcher,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
            'StreamDispatcher': grpc.unary_stream_rpc_method_handler(
                    servicer.StreamDispatcher,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
            'RegisterTools': grpc.unary_unary_rpc_method_handler(
                    servicer.RegisterTools,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
            'DeregisterTools': grpc.unary_unary_rpc_method_handler(
                    servicer.DeregisterTools,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
            'ToolExecutorStream': grpc.stream_stream_rpc_method_handler(
                    servicer.ToolExecutorStream,
                    request_deserializer=context__unit__pb2.ContextUnit.FromString,
                    response_serializer=context__unit__pb2.ContextUnit.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'contextrouter.RouterService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('contextrouter.RouterService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class RouterService(object):
    """=====================================================
    Router Service - AI Agent Orchestration
    =====================================================
    All methods use ContextUnit as input/output.
    Agent identification and input is passed via payload.
    =====================================================

    """

    @staticmethod
    def ExecuteAgent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/contextrouter.RouterService/ExecuteAgent',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def StreamAgent(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/contextrouter.RouterService/StreamAgent',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ExecuteDispatcher(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/contextrouter.RouterService/ExecuteDispatcher',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def StreamDispatcher(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_stream(
            request,
            target,
            '/contextrouter.RouterService/StreamDispatcher',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def RegisterTools(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/contextrouter.RouterService/RegisterTools',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def DeregisterTools(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/contextrouter.RouterService/DeregisterTools',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ToolExecutorStream(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/contextrouter.RouterService/ToolExecutorStream',
            context__unit__pb2.ContextUnit.SerializeToString,
            context__unit__pb2.ContextUnit.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
